# Списки и словари
## А также кортежи, множества и все, все, все...

Приветствую! На прошлой паре мы не зря изучили функцию range()... Сегодня вы узнаете:
- Насколько удобны массивы в Python 
- Что такое срезы, и как они помогут решать задачи
- Как написать команду для создания заполненного массива
- Какие есть структуры данных кроме массивов

## Массивы и индексы
Массивы в Python называются списками. Они имеют множество применений: хранить информацию об объектах одного рода (список шахматных фигур, набор точек, набор значений для функции), создавать набор значений для цикла `for` или даже заменять этот цикл `for`. Задать массив с любыми данными любых типов очень просто:
```py
a = [2, 4, 6, 8, 10]
b = ['Я', 'пишу', 'слова', 'отдельно']
с = [1]
```
Переменная `a` — это целый список. Как же теперь вывести отдельный элемент? Так же, как в жизни мы пользуемся нумерацией, когда пишем список чего-то, в Python у каждого элемента списка есть номер, который называется индексом, только нумерация начинается с нуля. То есть в списке из 5 элементов первый будет с индексом 0, а последний — 4:
```py
print(a[0])
>>> 2
print(a[4])
>>> 10
```
Отрицательные индексы, начиная с `-1`, позволяют вывести n-ный элемент с конца:
```py
print(a[-2])
>>> 8
```
Ещё массив всегда хранит свою длину, которую можно получить функцией `len()`:
```py
print(len(a))
>>> 5
```

### Кортежи — неизменяемые массивы
Запомните названия типов данных:  
- list — массив, он же список  
- tuple — неизменяемый массив  
  
Кортежи не отличаются от массивов ничем, кроме того, что их содержимое нельзя менять. Кортежи стоит использовать вместо списков всегда, когда мы не собираемся добавлять или убирать из него элементы при помощи кода. На практике большинство людей всё равно использует массивы, но они работают медленнее, так что есть, к чему стремиться:) Кортежи можно определить так:
```
a = (1, 2, 3)
b = (1,)
```
### Двухмерные массивы
В отличие от других языков программирования, в Питоне мы можем наполнять массивы и кортежи элементами разных типов:
```py
a = ['a', 2, ['t']]
```
Одним из элементов предыдущего массива является ещё один массив. Так мы можем создать уже двухмерный массив:
```py
double_list = [[1,2,3], [4,5,6], [7,8,9]]
```
Тогда к элементам можно обращаться так:
```py
print(double_list[1])
>>> [4,5,6]
print(double_list[1][0])
>>> 4
```
Давайте решим задачу из второго теста:
```
Дан массив для игры в крестики-нолики. Какое минимальное количество слов if понадобится,  
чтобы проверить выигрыш одного из игроков, если не использовать слова elif, else, switch и case?
a = [[0,0,0],
     [0,0,0],
     [0,0,0]]
```
Речь о том, чтобы написать код, который решит эту задачу с минимальным количеством условий. Это очень плохое решение с точки зрения кода, но в нём есть всего одно слово `if`:
```py
solutions = [[(0,0), (0,1), (0,2)], [(1,0), (1,1), (1,2)], [(2,0), (2,1), (2,2)],
             [(0,0), (1,0), (2,0)], [(0,1), (1,1), (2,1)], [(0,1), (1,1), (2,1)],
             [(0,0), (1,1), (2,2)], [(0,2), (1,1), (2,0)]] 
            # координаты крестиков/ноликов во всех возможных вариантах победы
for i in solutions:
    if a[i[0][0]][i[0][1]] == a[i[1][0]][i[1][1]] and a[i[1][0]][i[1][1]] == a[i[2][0]][i[2][1]]:
        print('Кто-то выиграл! Нам не важно, кто:)'
```
Решение ужасно не только потому, что вы наверняка запутались в индексах трёхмерного списка, подающихся в двухмерный списка, а ещё и потому, что для шахмат решений будет не восемь, а как минимум миллион (возможно, намного больше). Но в нём один `if`:)

## Операции с массивами
```py
a = ['Андрей', 'Кирилл', 'Владимир', 'Игнат']
```
Вот так просто элементы массива можно изменять:
```py
a[3] = 'Игорь'
```
Вот все способы добавить элемент в конец списка:
```py
a.append('Виктория')
a += ['Марина']
```
Первый способ мы используем по умолчанию. Второй — конкатенация — отлично подойдёт для того, чтобы добавить элемент в начало списка:
```py
a = ['Марина'] + a
print(a)
>>> ['Марина', 'Андрей', 'Кирилл', 'Владимир', 'Игорь', 'Виктория', 'Марина']
```
name = a.pop()
a.pop(5)
ind = a.index('Кирилл')
del a[ind]
a *= 2

### Задачи

# Срезы — способ взять часть массива или кортежа
print(a[:2])
print(a[1:])
print(a[1:3])
print(a[::2])
print(a[::-1])



max() min() sorted()

# Срезы, индексы и длина применимы и к строкам
b = 'Георгий'
print(b[-1])
print(b[2:5])
print(len(b))

# Множества — список уникальных элементов
a = set(a)
print(a)
a = list(a)

# Словари
d = {'Вероника': 232, 'Алёна': 267}
e = {}
d['Никита'] = 258

# Массивы и циклы
for i in range(len(a)):
  print(i, a[i])
for name in a:
  print(name)

# конструкторы
a = [i*2 for i in range(5)]
b = {i:i+1 for i in a}
# функции строк, count, join
решить задачу на крестики-нолики из 2 теста
