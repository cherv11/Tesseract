# Списки и словари
## А также кортежи, множества и все, все, все...

Приветствую! На прошлой паре мы не зря изучили функцию range()... Сегодня вы узнаете:
- Насколько удобны списки в Python 
- Что такое срезы, и как они помогут решать задачи
- Как написать команду для создания заполненного списка
- Какие есть структуры данных кроме списков

## Списки и индексы
Массивы в Python называются списками. Они имеют множество применений: хранить информацию об объектах одного рода (список шахматных фигур, набор точек, набор значений для функции), создавать набор значений для цикла `for` или даже заменять этот цикл `for`. Задать список с любыми данными любых типов очень просто:
```py
a = [2, 4, 6, 8, 10]
b = ['Я', 'пишу', 'слова', 'отдельно']
с = [1]
```
Переменная `a` — это целый список. Как же теперь вывести отдельный элемент? Так же, как в жизни мы пользуемся нумерацией, когда пишем список чего-то, в Python у каждого элемента списка есть номер, который называется индексом, только нумерация начинается с нуля. То есть в списке из 5 элементов первый будет с индексом 0, а последний — 4:
```py
print(a[0])
>>> 2
print(a[4])
>>> 10
```
Отрицательные индексы, начиная с `-1`, позволяют вывести n-ный элемент с конца:
```py
print(a[-2])
>>> 8
```
Ещё список всегда хранит свою длину, которую можно получить функцией `len()`:
```py
print(len(a))
>>> 5
```

### Кортежи — неизменяемые списки
Запомните названия типов данных:  
- list — массив, он же список  
- tuple — неизменяемый список 
  
Кортежи не отличаются от списков ничем, кроме того, что их содержимое нельзя менять. Кортежи стоит использовать вместо списков всегда, когда мы не собираемся добавлять или убирать из него элементы при помощи кода. На практике большинство людей всё равно использует списки, но они работают медленнее, так что есть, к чему стремиться:) Кортежи можно определить так:
```
a = (1, 2, 3)
b = (1,)
```
### Двухмерные списки
В отличие от других языков программирования, в Питоне мы можем наполнять списки и кортежи элементами разных типов:
```py
a = ['a', 2, ['t']]
```
Одним из элементов предыдущего списка является ещё один список. Так мы можем создать уже двухмерный список:
```py
double_list = [[1,2,3], [4,5,6], [7,8,9]]
```
Тогда к элементам можно обращаться так:
```py
print(double_list[1])
>>> [4,5,6]
print(double_list[1][0])
>>> 4
```
Давайте решим задачу из второго теста:
```
Дан массив для игры в крестики-нолики. Какое минимальное количество слов if понадобится,  
чтобы проверить выигрыш одного из игроков, если не использовать слова elif, else, switch и case?
a = [[0,0,0],
     [0,0,0],
     [0,0,0]]
```
Речь о том, чтобы написать код, который решит эту задачу с минимальным количеством условий. Это очень плохое решение с точки зрения кода, но в нём есть всего одно слово `if`:
```py
solutions = [[(0,0), (0,1), (0,2)], [(1,0), (1,1), (1,2)], [(2,0), (2,1), (2,2)],
             [(0,0), (1,0), (2,0)], [(0,1), (1,1), (2,1)], [(0,1), (1,1), (2,1)],
             [(0,0), (1,1), (2,2)], [(0,2), (1,1), (2,0)]] 
            # координаты крестиков/ноликов во всех возможных вариантах победы
for i in solutions:
    if a[i[0][0]][i[0][1]] == a[i[1][0]][i[1][1]] and a[i[1][0]][i[1][1]] == a[i[2][0]][i[2][1]]:
        print('Кто-то выиграл! Нам не важно, кто:)')
```
Решение ужасно не только потому, что вы наверняка запутались в индексах трёхмерного списка, подающихся в двухмерный списка, а ещё и потому, что для шахмат решений будет не восемь, а как минимум миллион (возможно, намного больше). Но в нём один `if`:)

## Операции со списками
```py
a = ['Андрей', 'Кирилл', 'Владимир', 'Игнат']
```
Вот так просто элементы списка можно изменять:
```py
a[3] = 'Игорь'
```
Вот все способы добавить элемент в конец списка:
```py
a.append('Виктория')
a += ['Марина']
```
Первый способ мы используем по умолчанию. Второй — конкатенация — отлично подойдёт для того, чтобы добавить элемент в начало списка:
```py
a = ['Марина'] + a
print(a)
>>> ['Марина', 'Андрей', 'Кирилл', 'Владимир', 'Игорь', 'Виктория', 'Марина']
```
Точно так же есть два способа убрать элемент. Первый — метод `pop()`. Метод — это функция, которая относится какому-то объекту и доступна только для переменных определённого типа данных. Вот так это выглядит:
```py
name = a.pop()
```
Как вы могли догадатсья, `append()` — это тоже метод. В переменную `name` при вызове функции будет записано то, что функция "возвращает". В данном случае это тот элемент, который мы удалили из списка. Если не подать в функцию аргумент, она удалит и вернёт последний элемент списка. Мы будто берём верхний лист из стопки. Если подать в качестве аргумента индекс, функция удалит его:
```py
a.pop(3)
>>> ['Марина', 'Андрей', 'Кирилл', 'Игорь', 'Виктория', 'Марина']
```
Ещё один способ убрать элемент — знать его индекс и воспользоваться оператором `del`. Или достать индекс методом `index()`:
```py
ind = a.index('Кирилл')
del a[ind]
```
### Задачи ❓
1. Выведите на экран все элементы списка, кроме первого и последнего, используя функцию `len()` и цикл `for`:
```py
a = [1, 2, 3, 4, 5, 6]
```
2. Дан список с числами. Добавьте в него элементы так, чтобы он содержал все целые числа от 1 до 9 по порядку:
```py
a = [3, 4, 5, 6]
```
3. Дан список нулей и единиц. Любым способом сделайте так, чтобы количество нулей и единиц в нём было равным:
```py
a = [1, 0, 1, 1, 0, 0, 1]
```

## Срезы — способ взять часть списка или кортежа
Использование срезов невероятно похоже на использование функции `range()`. Конечно, это не случайно. Давайте сделаем ещё один список и посмотрим, как можно вывести его часть при помощи `range()`:
```py
a = ['Марина', 'Андрей', 'Кирилл', 'Владимир', 'Игорь', 'Виктория']

for i in range(3):
    print(a[i])
>>> 'Марина' 'Андрей' 'Кирилл'    # в столбик

for i in range(5, len(a)):
    print(a[i])
>>> 'Виктория'

for i in range(2,4):
    print(a[i])
>>> 'Кирилл' 'Владимир'    # в столбик
    
for i in range(0,6,2):
    print(a[i])
>>> 'Марина' 'Кирилл' 'Игорь'    # в столбик  
```
А вот то же самое, но при помощи срезов, только здесь у нас получится список, а не набор значений в столбик:
```py
print(a[:3])
>>> ['Марина', 'Андрей', 'Кирилл']

print(a[5:])
>>> ['Виктория']

print(a[2:4])
>>> ['Кирилл', 'Владимир']
    
print(a[:6:2])
>>> ['Марина', 'Кирилл', 'Игорь']
```
Написав одно число в квадратных скобках, мы получим **объект**. Написав хотя бы одно двоеточие, мы получим **срез** — просто ещё один список. Число перед двоеточием — начало среза, а после — конец. Так же, как и в `range()`, первое число входит в интервал, а второе — нет. Если перед/после двоеточия нет числа, компьютер считает, что мы написали `0` или `len(a)` соответственно. То есть запись `a[:3]` означает "От начала до 3", а запись `a[5:]` — "От 5 и до конца"  
Если двоеточия у нас два, то можно добавить третье число — шаг. Всё как в функции `range()`.

### Строки как массивы
Строки в Python — это тоже массивы. Именно поэтому мы на прошлой паре могли использовать их для цикла `for`. Для них работают функция длины, индексы и срезы:
```py
b = 'Георгий'
print(b[-1])
>>> 'й'
print(b[2:5])
>>> 'орг'
print(len(b))
>>> 7
```

### Задачи ❓
4. В срезах можно использовать отрицательные индексы. Давайте решим эту задачу снова, но уже с помощью этой подсказки. Выведите на экран все элементы списка, кроме первого и последнего:
```py
a = [10, 11, 12, 13, 14, 15]
```
5. Определите, что будет выведено на экран. В ответ нужно записать цифры — элементы списка, можно без запятых и скобок:
```py
a = [1, 2, 3, 4]
print(a[:2])
print(a[1:])
print(a[1:3])
print(a[::2])
print(a[::-1])
```

max() min() sorted()
# Множества — список уникальных элементов
a = set(a)
print(a)
a = list(a)

# Словари
d = {'Вероника': 232, 'Алёна': 267}
e = {}
d['Никита'] = 258

# Массивы и циклы
for i in range(len(a)):
  print(i, a[i])
for name in a:
  print(name)

# конструкторы
a = [i*2 for i in range(5)]
b = {i:i+1 for i in a}
# функции строк, count, join
решить задачу на крестики-нолики из 2 теста
