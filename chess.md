# Пишем шахматы. Часть 2: Перемещение, меню, ИИ
Привет-привет! [Продолжаем](https://cherv11.github.io/Tesseract/pics_and_shapes) писать шахматы. Сегодня мы:
- Допишем основной код программы
- Создадим меню, из которого будут открываться разные игровые режимы
- Найдём хороший искусственный интеллект для наших шахмат

## Анализ доски и перемещение фигур
На прошлой паре мы закончили всё, не считая двух функций — `move()` и `canmove()`. Давайте в них разберёмся.  
Функции применяются только три раза вот в этих случаях:  
![image](https://user-images.githubusercontent.com/56085790/142756446-3b9953d0-8147-42c3-bac0-372d771bad7a.png)

Отсюда видно, что функция `move()` принимает координаты, откуда и куда переместить фигуру, и должна **только** переместить её с одного места в другое. Какую фигуру куда можно, а куда нельзя перемещать, решает функция `canmove()`.  
```py
def move(sh, pos):
    shape = board[sh[0]][sh[1]]
    board[pos[0]][pos[1]] = shape
    board[sh[0]][sh[1]] = ''
 ```
 Но правила шахмат не ограничиваются одним лишь перемещением фигур. В эту функцию необходимо добавить такие вещи, как превращение пешки в ферзя, если она добралась до конца поля:
 ```py
     if shape[0] == 'p':
        if (shape.endswith('0') and bottomteam == '0') or (shape.endswith('1') and bottomteam == '1'): 
            if pos[0] == 0:
                board[pos[0]][pos[1]] = 'Q'+shape[1]
        else:  # Этот if/else зависит от того, какая команда начинает внизу
            if pos[0] == 7:
                board[pos[0]][pos[1]] = 'Q'+shape[1]
 ```
 А вы задумывались, как игра должна закончится? Нужно добавить выход из игры (или в меню, или не выход, а надпись какую) при убийстве короля:
 ```py
    enemy = '0' if shape.endswith('1') else '1'  # Скажи мне, кто твой враг, и я скажу, кто ты...
    eking = ()
    for i in range(8):
        for j in range(8):
            if board[i][j] == 'K'+enemy:  # Находим вражеского короля на поле
                eking = (i,j)
    if not eking:  # Если его нет, значит, его убили))
        exit()
 ```
 Итак, мы получили это:
 ```py
 def move(sh, pos):
    shape = board[sh[0]][sh[1]]
    board[pos[0]][pos[1]] = shape
    board[sh[0]][sh[1]] = ''

    if shape[0] == 'p':
        if (shape.endswith('0') and bottomteam == '0') or (shape.endswith('1') and bottomteam == '1'):
            if pos[0] == 0:
                board[pos[0]][pos[1]] = 'Q'+shape[1]
        else:
            if pos[0] == 7:
                board[pos[0]][pos[1]] = 'Q'+shape[1]

    enemy = '0' if shape.endswith('1') else '1'
    eking = ()
    for i in range(8):
        for j in range(8):
            if board[i][j] == 'K'+enemy:
                eking = (i,j)
    if not eking:
        exit()
````
Теперь определимся с путями. Функция `canmove()` занимает целых 120 строк, в ней есть не только расчёт клеток, но ещё и такие вещи, как старт пешки на две клетки (и должна быть рокировка). Давайте посмотрим на часть этого кода:
```py

```
